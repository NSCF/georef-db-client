{"version":3,"sources":["../src/components/georef/georefFuncs.js"],"names":["Georef","require","fetchCandidateGeorefs","groupLocalities","elasticindex","length","elasticFetches","loc","push","fetchGeorefsForLoc","fetchResults","Promise","all","err","georefIndex","entries","index","elasticGeorefs","elasticGeoref","georef","Object","assign","_source","selected","decimalCoordinatesOkay","georefID","Error","locString","search","encodeURI","url","response","fetch","data","json","updateGeorefStats","Firebase","georefsAdded","recordsGeoreferenced","userID","userName","datasetID","yearmonth","getYearMonth","Date","yearweek","getYearWeek","now","today","getTime","getTimezoneOffset","toISOString","split","refstrings","proms","rs","val","endsWith","ref","updateStat","updateLastGeorefsAdded","transaction","current","updateLastGeorefsAddedBy","updateLastGeorefsAddedByID","updateDatasetLastGeorefsAdded","updateDatasetLastGeorefsAddedBy","updateDatasetLastGeorefsAddedByID","console","log","statRef","increment","d","UTC","getFullYear","getMonth","getDate","setUTCDate","getUTCDate","getUTCDay","yearStart","getUTCFullYear","weekNo","Math","ceil","toString","padStart","y","m","updateDatasetStats","Firestore","datasetRef","groupComplete","runTransaction","get","then","docSnap","exists","update","recordsCompleted","lastGeoreference","lastGeoreferenceBy","groupsComplete","i","catch","error","module","exports"],"mappings":"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","file":"georefFuncs.js","sourcesContent":["//FUNCTIONS USED BY georef COMPONENT\r\n\r\nconst Georef =require('./Georef.js')\r\n\r\nconst fetchCandidateGeorefs = async (groupLocalities, elasticindex) => {\r\n  //groupLocalities must be a set of {id: ..., loc: ... } objects\r\n\r\n  if(groupLocalities && groupLocalities.length){\r\n    let elasticFetches = []//promise array\r\n\r\n    for (let loc of groupLocalities){\r\n      elasticFetches.push(fetchGeorefsForLoc(loc.loc, elasticindex))\r\n    }\r\n\r\n    let fetchResults\r\n\r\n    try {\r\n      fetchResults = await Promise.all(elasticFetches)\r\n    }\r\n    catch(err){\r\n      throw err\r\n    }\r\n    \r\n    //get the uniques and record who they belong to\r\n    //an object as a dictionary of all the georefs\r\n    //an object with the index of each groupLoc and its associated georefs\r\n    //on select of groupLoc/s destructure all the georef keys from the groupLoc index and make a set\r\n    //iterate the georef dictionary and update each one as visible or not\r\n    \r\n    let georefIndex = {} //it will be a and object of georefID: georefobject pairs\r\n    \r\n    if(fetchResults.length){\r\n      for (let [index, elasticGeorefs] of fetchResults.entries()){\r\n        if(elasticGeorefs.length){\r\n          for (let elasticGeoref of elasticGeorefs){\r\n            \r\n            let georef = Object.assign(new Georef, elasticGeoref._source)\r\n            if(georef.selected) { //just in case any of these sneak through\r\n              delete georef.selected\r\n            }\r\n\r\n            if(!georef.decimalCoordinatesOkay){\r\n              //console.log('error with coordinates for georef', elasticGeoref._id)\r\n              continue\r\n            }\r\n\r\n            if(!georefIndex[georef.georefID]){\r\n              georefIndex[georef.georefID] = georef\r\n            }  \r\n          }\r\n        } \r\n      }\r\n    }\r\n\r\n    //for testing\r\n    /*\r\n    let georeflocs = []\r\n    for (const [key, value] of Object.entries(georefIndex)) {\r\n      georeflocs.push(value.locality)\r\n    }\r\n    console.log(georeflocs)\r\n    */\r\n\r\n    return {\r\n      georefIndex\r\n    }\r\n  }\r\n  else {\r\n    throw new Error('no values supplied')\r\n  }\r\n}\r\n\r\n//just a helper for above\r\nconst fetchGeorefsForLoc = async (locString, index) => {\r\n  let search = encodeURI(locString)\r\n  let url = `https://us-central1-georef-745b9.cloudfunctions.net/getgeorefs?search=${search}&index=${index}`\r\n  let response = await fetch(url)\r\n  let data = await response.json()\r\n  return data\r\n}\r\n\r\nconst updateGeorefStats = async (Firebase, georefsAdded, recordsGeoreferenced, userID, userName, datasetID) => {\r\n  let yearmonth = getYearMonth(new Date())\r\n  let yearweek = getYearWeek(new Date())\r\n  let now = new Date()\r\n  let today = new Date(now.getTime() - now.getTimezoneOffset() * 60 * 1000).toISOString().split('T')[0] //we need this horrible thing to adjust for time zone differences as getTime gives a utc time\r\n   \r\n  let refstrings = [\r\n    //totals\r\n    'stats/georefsAdded',\r\n    'stats/recordsGeoreferenced',\r\n    `stats/weekly/${yearweek}/georefsAdded`, \r\n    `stats/weekly/${yearweek}/recordsGeoreferenced`, \r\n    `stats/monthly/${yearmonth}/georefsAdded`, \r\n    `stats/monthly/${yearmonth}/recordsGeoreferenced`, \r\n\r\n    //perDataset\r\n    `stats/perDataset/${datasetID}/georefsAdded`,\r\n    `stats/perDataset/${datasetID}/recordsGeoreferenced`,\r\n    `stats/perDataset/${datasetID}/perUser/${userID}/georefsAdded`,\r\n    `stats/perDataset/${datasetID}/perUser/${userID}/recordsGeoreferenced`,\r\n    `stats/perDataset/${datasetID}/perUser/${userID}/daily/${today}/georefsAdded`,\r\n    `stats/perDataset/${datasetID}/perUser/${userID}/daily/${today}/recordsGeoreferenced`,\r\n    `stats/perDataset/${datasetID}/perUser/${userID}/weekly/${yearweek}/georefsAdded`,\r\n    `stats/perDataset/${datasetID}/perUser/${userID}/weekly/${yearweek}/recordsGeoreferenced`,\r\n    `stats/perDataset/${datasetID}/perUser/${userID}/monthly/${yearmonth}/georefsAdded`,\r\n    `stats/perDataset/${datasetID}/perUser/${userID}/monthly/${yearmonth}/recordsGeoreferenced`,\r\n\r\n    //perUser\r\n    `stats/perUser/${userID}/georefsAdded`,\r\n    `stats/perUser/${userID}/recordsGeoreferenced`,\r\n    `stats/perUser/${userID}/daily/${today}/georefsAdded`,\r\n    `stats/perUser/${userID}/daily/${today}/recordsGeoreferenced`,\r\n    `stats/perUser/${userID}/weekly/${yearweek}/georefsAdded`,\r\n    `stats/perUser/${userID}/weekly/${yearweek}/recordsGeoreferenced`,\r\n    `stats/perUser/${userID}/monthly/${yearmonth}/georefsAdded`,\r\n    `stats/perUser/${userID}/monthly/${yearmonth}/recordsGeoreferenced`\r\n  ]\r\n\r\n  let proms = []\r\n  for (let rs of refstrings){\r\n    let val = georefsAdded\r\n    if (rs.endsWith('recordsGeoreferenced')){\r\n      val = recordsGeoreferenced\r\n    }\r\n    let ref = Firebase.ref(rs)\r\n    proms.push(updateStat(ref, val))\r\n  }\r\n\r\n  let updateLastGeorefsAdded = Firebase.ref('stats/lastGeorefAdded').transaction(current => {\r\n    current = Date.now()\r\n    return current\r\n  })\r\n\r\n  let updateLastGeorefsAddedBy = Firebase.ref('stats/lastGeorefAddedBy').transaction(current => {\r\n    current = userName\r\n    return current\r\n  })\r\n\r\n  let updateLastGeorefsAddedByID = Firebase.ref('stats/lastGeorefAddedByID').transaction(current => {\r\n    current = userID\r\n    return current\r\n  })\r\n\r\n  let updateDatasetLastGeorefsAdded = Firebase.ref(`stats/perDataset/${datasetID}/lastGeorefAdded`).transaction(current => {\r\n    current = Date.now()\r\n    return current\r\n  })\r\n\r\n  let updateDatasetLastGeorefsAddedBy = Firebase.ref(`stats/perDataset/${datasetID}/lastGeorefAddedBy`).transaction(current => {\r\n    current = userName\r\n    return current\r\n  })\r\n\r\n  let updateDatasetLastGeorefsAddedByID = Firebase.ref(`stats/perDataset/${datasetID}/lastGeorefAddedByID`).transaction(current => {\r\n    current = userID\r\n    return current\r\n  })\r\n\r\n  proms.push(updateLastGeorefsAdded)\r\n  proms.push(updateLastGeorefsAddedBy)\r\n  proms.push(updateLastGeorefsAddedByID)\r\n\r\n  proms.push(updateDatasetLastGeorefsAdded)\r\n  proms.push(updateDatasetLastGeorefsAddedBy)\r\n  proms.push(updateDatasetLastGeorefsAddedByID)\r\n\r\n  await Promise.all(proms) //thats 30 in total!!\r\n\r\n  console.log('georef count stats updated')\r\n  \r\n}\r\n\r\nconst updateStat = (statRef, increment) => {\r\n  statRef.transaction( current => {\r\n    if(current){\r\n      current += increment\r\n    }\r\n    else {\r\n      current = increment\r\n    }\r\n    return current\r\n  })\r\n}\r\n\r\nconst getYearWeek = d => {\r\n  // Copy date so don't modify original\r\n  d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));\r\n  // Set to nearest Thursday: current date + 4 - current day number\r\n  // Make Sunday's day number 7\r\n  d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay()||7));\r\n  // Get first day of year\r\n  var yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));\r\n  // Calculate full weeks to nearest Thursday\r\n  var weekNo = Math.ceil(( ( (d - yearStart) / 86400000) + 1)/7);\r\n  // Return array of year and week number\r\n  return `${d.getUTCFullYear()} ${weekNo.toString().padStart(2, '0')}`\r\n}\r\n\r\nconst getYearMonth = d => {\r\nlet y = d.getUTCFullYear()\r\nlet m = d.getMonth() + 1\r\nreturn `${y} ${m.toString().padStart(2, '0')}`\r\n}\r\n\r\nconst updateDatasetStats = (Firestore, datasetRef, recordsGeoreferenced, userID, groupComplete) => {\r\n  return Firestore.runTransaction(function(transaction) {\r\n    // This code may get re-run multiple times if there are conflicts.\r\n    return transaction.get(datasetRef).then(function(docSnap) {\r\n      if (!docSnap.exists) {\r\n          throw \"Document does not exist!\";\r\n      }\r\n\r\n      let data = docSnap.data()\r\n      let update = {\r\n        recordsCompleted: data.recordsCompleted += recordsGeoreferenced, \r\n        lastGeoreference: Date.now(),\r\n        lastGeoreferenceBy: userID\r\n      }\r\n\r\n      if(groupComplete) {\r\n        //console.log('updating groups completed')\r\n        //console.log('Value of dataset.groupsComplete:', data.groupsComplete)\r\n        update.groupsComplete = data.groupsComplete++\r\n      }\r\n\r\n      transaction.update(datasetRef, update);\r\n    });\r\n  }).then(function() {\r\n    let i = 0 //do nothing\r\n    //console.log(\"Dataset record updated!\");\r\n  }).catch(function(error) {\r\n    throw error;\r\n  });\r\n}\r\n\r\nmodule.exports = {\r\n  updateGeorefStats,\r\n  updateDatasetStats, \r\n  fetchCandidateGeorefs\r\n}\r\n\r\n"]}